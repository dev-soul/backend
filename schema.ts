/*
 * THIS FILE IS AUTOGENERATED â€” DO NOT EDIT IT
 */
import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
import { Context } from './app/Context';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type RequireFields<T, K extends keyof T> = { [X in Exclude<keyof T, K>]?: T[X] } & {
    [P in K]-?: NonNullable<T[P]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export interface Scalars {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    Binary: any;
    Date: any;
    Datetime: any;
    GqlBigNumber: string;
    JSON: any;
    UUID: string;
}

export interface GqlBalancerPool {
    __typename?: 'GqlBalancerPool';
    address: Scalars['String'];
    block: Scalars['String'];
    holdersCount: Scalars['String'];
    id: Scalars['String'];
    name?: Maybe<Scalars['String']>;
    swapFee: Scalars['String'];
    swapsCount: Scalars['String'];
    symbol?: Maybe<Scalars['String']>;
    timestamp: Scalars['String'];
    totalLiquidity: Scalars['String'];
    totalShares: Scalars['String'];
    totalSwapFee: Scalars['String'];
}

export interface GqlHistoricalTokenPrice {
    __typename?: 'GqlHistoricalTokenPrice';
    address: Scalars['String'];
    prices: Array<GqlHistoricalTokenPriceEntry>;
}

export interface GqlHistoricalTokenPriceEntry {
    __typename?: 'GqlHistoricalTokenPriceEntry';
    price: Scalars['Float'];
    timestamp: Scalars['String'];
}

export interface GqlTokenPrice {
    __typename?: 'GqlTokenPrice';
    address: Scalars['String'];
    price: Scalars['Float'];
}

export interface GqlUserPoolData {
    __typename?: 'GqlUserPoolData';
    id: Scalars['String'];
    myFees: Scalars['GqlBigNumber'];
    name: Scalars['String'];
    percentOfPortfolio: Scalars['Float'];
    percentShare: Scalars['Float'];
    poolAddress: Scalars['String'];
    poolId: Scalars['String'];
    priceChange: Scalars['GqlBigNumber'];
    priceChangePercent: Scalars['Float'];
    pricePerShare: Scalars['GqlBigNumber'];
    shares: Scalars['GqlBigNumber'];
    swapFees: Scalars['GqlBigNumber'];
    swapVolume: Scalars['GqlBigNumber'];
    tokens: Array<GqlUserTokenData>;
    totalValue: Scalars['GqlBigNumber'];
}

export interface GqlUserPortfolioData {
    __typename?: 'GqlUserPortfolioData';
    myFees: Scalars['GqlBigNumber'];
    pools: Array<GqlUserPoolData>;
    timestamp: Scalars['Int'];
    tokens: Array<GqlUserTokenData>;
    totalSwapFees: Scalars['GqlBigNumber'];
    totalSwapVolume: Scalars['GqlBigNumber'];
    totalValue: Scalars['GqlBigNumber'];
}

export interface GqlUserTokenData {
    __typename?: 'GqlUserTokenData';
    address: Scalars['String'];
    balance: Scalars['GqlBigNumber'];
    id: Scalars['String'];
    name: Scalars['String'];
    percentOfPortfolio: Scalars['Float'];
    pricePerToken: Scalars['GqlBigNumber'];
    symbol: Scalars['String'];
    totalValue: Scalars['GqlBigNumber'];
}

export interface Mutation {
    __typename?: 'Mutation';
    clearCacheAtBlock: Scalars['Boolean'];
    clearCachedPools: Scalars['Boolean'];
    emptyMutation: Scalars['Boolean'];
    reloadTokenPrices?: Maybe<Scalars['Boolean']>;
}

export interface MutationClearCacheAtBlockArgs {
    block: Scalars['Int'];
}

export interface Query {
    __typename?: 'Query';
    getCachedPools: Array<GqlBalancerPool>;
    portfolioGetUserPortfolio: GqlUserPortfolioData;
    portfolioGetUserPortfolioHistory: Array<GqlUserPortfolioData>;
    tokenPriceGetCurrentPrices: Array<GqlTokenPrice>;
    tokenPriceGetHistoricalPrices: Array<GqlHistoricalTokenPrice>;
}

export interface QueryTokenPriceGetHistoricalPricesArgs {
    addresses: Array<Scalars['String']>;
}

export interface TranslatedString {
    __typename?: 'TranslatedString';
    de: Scalars['String'];
    en: Scalars['String'];
}

export type WithIndex<TObject> = TObject & Record<string, any>;
export type ResolversObject<TObject> = WithIndex<TObject>;

export type ResolverTypeWrapper<T> = Promise<T> | T;

export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
    resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
    | ResolverFn<TResult, TParent, TContext, TArgs>
    | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
    subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
    resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
    subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
    resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
    | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
    | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
    | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
    | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
    parent: TParent,
    context: TContext,
    info: GraphQLResolveInfo,
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (
    obj: T,
    context: TContext,
    info: GraphQLResolveInfo,
) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
    next: NextResolverFn<TResult>,
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = ResolversObject<{
    Binary: ResolverTypeWrapper<Scalars['Binary']>;
    Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
    Date: ResolverTypeWrapper<Scalars['Date']>;
    Datetime: ResolverTypeWrapper<Scalars['Datetime']>;
    Float: ResolverTypeWrapper<Scalars['Float']>;
    GqlBalancerPool: ResolverTypeWrapper<GqlBalancerPool>;
    GqlBigNumber: ResolverTypeWrapper<Scalars['GqlBigNumber']>;
    GqlHistoricalTokenPrice: ResolverTypeWrapper<GqlHistoricalTokenPrice>;
    GqlHistoricalTokenPriceEntry: ResolverTypeWrapper<GqlHistoricalTokenPriceEntry>;
    GqlTokenPrice: ResolverTypeWrapper<GqlTokenPrice>;
    GqlUserPoolData: ResolverTypeWrapper<GqlUserPoolData>;
    GqlUserPortfolioData: ResolverTypeWrapper<GqlUserPortfolioData>;
    GqlUserTokenData: ResolverTypeWrapper<GqlUserTokenData>;
    Int: ResolverTypeWrapper<Scalars['Int']>;
    JSON: ResolverTypeWrapper<Scalars['JSON']>;
    Mutation: ResolverTypeWrapper<{}>;
    Query: ResolverTypeWrapper<{}>;
    String: ResolverTypeWrapper<Scalars['String']>;
    TranslatedString: ResolverTypeWrapper<TranslatedString>;
    UUID: ResolverTypeWrapper<Scalars['UUID']>;
}>;

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = ResolversObject<{
    Binary: Scalars['Binary'];
    Boolean: Scalars['Boolean'];
    Date: Scalars['Date'];
    Datetime: Scalars['Datetime'];
    Float: Scalars['Float'];
    GqlBalancerPool: GqlBalancerPool;
    GqlBigNumber: Scalars['GqlBigNumber'];
    GqlHistoricalTokenPrice: GqlHistoricalTokenPrice;
    GqlHistoricalTokenPriceEntry: GqlHistoricalTokenPriceEntry;
    GqlTokenPrice: GqlTokenPrice;
    GqlUserPoolData: GqlUserPoolData;
    GqlUserPortfolioData: GqlUserPortfolioData;
    GqlUserTokenData: GqlUserTokenData;
    Int: Scalars['Int'];
    JSON: Scalars['JSON'];
    Mutation: {};
    Query: {};
    String: Scalars['String'];
    TranslatedString: TranslatedString;
    UUID: Scalars['UUID'];
}>;

export interface BinaryScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Binary'], any> {
    name: 'Binary';
}

export interface DateScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Date'], any> {
    name: 'Date';
}

export interface DatetimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Datetime'], any> {
    name: 'Datetime';
}

export type GqlBalancerPoolResolvers<
    ContextType = Context,
    ParentType extends ResolversParentTypes['GqlBalancerPool'] = ResolversParentTypes['GqlBalancerPool'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    block?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    holdersCount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    swapFee?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    swapsCount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    symbol?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    timestamp?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    totalLiquidity?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    totalShares?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    totalSwapFee?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface GqlBigNumberScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['GqlBigNumber'], any> {
    name: 'GqlBigNumber';
}

export type GqlHistoricalTokenPriceResolvers<
    ContextType = Context,
    ParentType extends ResolversParentTypes['GqlHistoricalTokenPrice'] = ResolversParentTypes['GqlHistoricalTokenPrice'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    prices?: Resolver<Array<ResolversTypes['GqlHistoricalTokenPriceEntry']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlHistoricalTokenPriceEntryResolvers<
    ContextType = Context,
    ParentType extends ResolversParentTypes['GqlHistoricalTokenPriceEntry'] = ResolversParentTypes['GqlHistoricalTokenPriceEntry'],
> = ResolversObject<{
    price?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    timestamp?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlTokenPriceResolvers<
    ContextType = Context,
    ParentType extends ResolversParentTypes['GqlTokenPrice'] = ResolversParentTypes['GqlTokenPrice'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    price?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlUserPoolDataResolvers<
    ContextType = Context,
    ParentType extends ResolversParentTypes['GqlUserPoolData'] = ResolversParentTypes['GqlUserPoolData'],
> = ResolversObject<{
    id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    myFees?: Resolver<ResolversTypes['GqlBigNumber'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    percentOfPortfolio?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    percentShare?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    poolAddress?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    poolId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    priceChange?: Resolver<ResolversTypes['GqlBigNumber'], ParentType, ContextType>;
    priceChangePercent?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    pricePerShare?: Resolver<ResolversTypes['GqlBigNumber'], ParentType, ContextType>;
    shares?: Resolver<ResolversTypes['GqlBigNumber'], ParentType, ContextType>;
    swapFees?: Resolver<ResolversTypes['GqlBigNumber'], ParentType, ContextType>;
    swapVolume?: Resolver<ResolversTypes['GqlBigNumber'], ParentType, ContextType>;
    tokens?: Resolver<Array<ResolversTypes['GqlUserTokenData']>, ParentType, ContextType>;
    totalValue?: Resolver<ResolversTypes['GqlBigNumber'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlUserPortfolioDataResolvers<
    ContextType = Context,
    ParentType extends ResolversParentTypes['GqlUserPortfolioData'] = ResolversParentTypes['GqlUserPortfolioData'],
> = ResolversObject<{
    myFees?: Resolver<ResolversTypes['GqlBigNumber'], ParentType, ContextType>;
    pools?: Resolver<Array<ResolversTypes['GqlUserPoolData']>, ParentType, ContextType>;
    timestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    tokens?: Resolver<Array<ResolversTypes['GqlUserTokenData']>, ParentType, ContextType>;
    totalSwapFees?: Resolver<ResolversTypes['GqlBigNumber'], ParentType, ContextType>;
    totalSwapVolume?: Resolver<ResolversTypes['GqlBigNumber'], ParentType, ContextType>;
    totalValue?: Resolver<ResolversTypes['GqlBigNumber'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlUserTokenDataResolvers<
    ContextType = Context,
    ParentType extends ResolversParentTypes['GqlUserTokenData'] = ResolversParentTypes['GqlUserTokenData'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    balance?: Resolver<ResolversTypes['GqlBigNumber'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    percentOfPortfolio?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    pricePerToken?: Resolver<ResolversTypes['GqlBigNumber'], ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    totalValue?: Resolver<ResolversTypes['GqlBigNumber'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface JsonScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSON'], any> {
    name: 'JSON';
}

export type MutationResolvers<
    ContextType = Context,
    ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation'],
> = ResolversObject<{
    clearCacheAtBlock?: Resolver<
        ResolversTypes['Boolean'],
        ParentType,
        ContextType,
        RequireFields<MutationClearCacheAtBlockArgs, 'block'>
    >;
    clearCachedPools?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    emptyMutation?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    reloadTokenPrices?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
}>;

export type QueryResolvers<
    ContextType = Context,
    ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query'],
> = ResolversObject<{
    getCachedPools?: Resolver<Array<ResolversTypes['GqlBalancerPool']>, ParentType, ContextType>;
    portfolioGetUserPortfolio?: Resolver<ResolversTypes['GqlUserPortfolioData'], ParentType, ContextType>;
    portfolioGetUserPortfolioHistory?: Resolver<Array<ResolversTypes['GqlUserPortfolioData']>, ParentType, ContextType>;
    tokenPriceGetCurrentPrices?: Resolver<Array<ResolversTypes['GqlTokenPrice']>, ParentType, ContextType>;
    tokenPriceGetHistoricalPrices?: Resolver<
        Array<ResolversTypes['GqlHistoricalTokenPrice']>,
        ParentType,
        ContextType,
        RequireFields<QueryTokenPriceGetHistoricalPricesArgs, 'addresses'>
    >;
}>;

export type TranslatedStringResolvers<
    ContextType = Context,
    ParentType extends ResolversParentTypes['TranslatedString'] = ResolversParentTypes['TranslatedString'],
> = ResolversObject<{
    de?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    en?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface UuidScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['UUID'], any> {
    name: 'UUID';
}

export type Resolvers<ContextType = Context> = ResolversObject<{
    Binary?: GraphQLScalarType;
    Date?: GraphQLScalarType;
    Datetime?: GraphQLScalarType;
    GqlBalancerPool?: GqlBalancerPoolResolvers<ContextType>;
    GqlBigNumber?: GraphQLScalarType;
    GqlHistoricalTokenPrice?: GqlHistoricalTokenPriceResolvers<ContextType>;
    GqlHistoricalTokenPriceEntry?: GqlHistoricalTokenPriceEntryResolvers<ContextType>;
    GqlTokenPrice?: GqlTokenPriceResolvers<ContextType>;
    GqlUserPoolData?: GqlUserPoolDataResolvers<ContextType>;
    GqlUserPortfolioData?: GqlUserPortfolioDataResolvers<ContextType>;
    GqlUserTokenData?: GqlUserTokenDataResolvers<ContextType>;
    JSON?: GraphQLScalarType;
    Mutation?: MutationResolvers<ContextType>;
    Query?: QueryResolvers<ContextType>;
    TranslatedString?: TranslatedStringResolvers<ContextType>;
    UUID?: GraphQLScalarType;
}>;
